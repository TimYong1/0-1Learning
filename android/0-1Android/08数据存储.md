# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")
![alt text](../../static/common/svg/luoxiaosheng_gitee.svg "码云")


## 数据存储

Android 五大存储
SharedPreferences 方式
SharedPreferences 是使用键值对的方式进行存储数据的。
想要使用SharedPreferences 来存储数据，首先主要获取到SharedPreferences 对象。Android提供了三种方法用于获取SharedPreferences对象：
1，Context类中的getSharedPreferences(）方法

//此方法接收两个参数，一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在/data/data/<package name>/shared_prefs/目录下
//第二个参数用于指定操作模式，目前只有MODE_PRIVATE这种模式，和直接传入0效果相同
SharedPreferences.Editor editor = getSharedPreferences("data",MODE_PRIVATE).edit();
editor.putString("name", "Tom");
editor.putInt("age",13);
editor.putBoolean("married",false);
editor.apply();
1
2
3
4
5
6
7
2，Activity类中的getPreferences()方法

//这个方法和Context中的getSharedPreferences()方法很类似，不过它只接收一个操作模式，因为使用这个方法时会自动将当前活动的类名作为SharedPreferences的文件名
1
3，PreferencesManager类中的getDefaultSharedPreferences()方法

//这是一个静态方法，它接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件
1
得到了SharedPreferences对象后， 就可以开始想SharedPreferences文件中存储数据了，主要可以分为三步：
（1）调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象
（2）向SharedPreferences.Editor 对象中添加数据，比如添加一个布尔值，可以使用putBoolean() 方法
（3）调用apply()方法的添加的数据提交，从而完成数据存储操作

SharedPreferences中读取数据
SharedPreferences pref = getSharedPreferences("data",MODE_PRIVATE	);
String name = pref.getString("name","");
int age = pref.getInt("age",0);
boolean married = pref.getBoolean("married", false);
1
2
3
4
文件存储方式
SQList 存储方式
Android 为了让我们能够更加方便的管理数据库，专门提供了一个SQLiteOpenHelper 帮助类，借助这个类可以非常简单的将数据库进行创建好升级。
SQLiteOpenHelper 中有两个非常重要的实例方法，getReadableDatabase() 和 getWritableDatabase() 。这两个方法可以创建或者打开一个现有的数据库（如果数据库存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入（如磁盘空间已满），getReadableDatabase方法返回的对象将以只读的方式打开数据库，而getWeitableDatabase则出现异常

例子（在指定路径下创建数据库文件 .db ）

public class MainActivity extends Activity {
	public static final String PATH_ONE = "KogBill";
	public static final String PATH_NAME = "KogBill.db";
	private SQLiteDatabase db;    //声明SQLiteDatabase ，该对象可以操作数据库

	String path = Environment.getExternalStorageDirectory().getAbsolutePath();
	String path1 = path + File.separator + PATH_ONE;   //需要创建的路径
	String path2 = path + File.separator + PATH_ONE + 
			File.separator + PATH_NAME;  							//需要创建的文件

	@Override
	protected void onCreate(Bundle savedInstanceState){
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		File f = new File(path1);
		if( !f.exists()){  //创建数据库文件路径
			f.mkdirs();
		}	
		//实例化MySQLiteHelper ，创建指定目录下数据库文件，并创建表
		MySQLiteHelper mSQL = new MySQLiteHelper(MainActivity.this, path2);
		db = mSQL.getWritableDatabase();
	}

	class MySQLiteHelper extends SQLiteOpenHelper{
			private static final int DATABASE_VERSION = 1;//数据库版本号
			private static final String CREATE_TABLE = "create table kog_bill ("
		            + "_id integer primary key autoincrement,"
		            + "date text, "
		            + "breakfast text, "
		            + "lunch text,"
		            + "dinner text,"
		            + "happy text,"
		            + "other text,"
		            + "spare text)";
			
			//方便创建实例，简化构造方法，方法内调用4参数构造方法
			//参数 name 可以是 数据库名称，也可以数据库文件路径（即可以指定数据库文件路径）
			public MySQLiteHelper(Context context, String name) {
				this(context, name, null, DATABASE_VERSION);
			}
			//必须要实现的方法
			public MySQLiteHelper(Context context, String name, CursorFactory factory, int version) {
				super(context, name, factory, version);
			}
	
			@Override
			public void onCreate(SQLiteDatabase db) {
				// 第一次创建数据库时 才会调用
				Log.e("mylog", "创建数据库表");
				db.execSQL(CREATE_TABLE);
			}
	
			@Override
			public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			}
			
		}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
根据上述代码，便获得db对象，通过db（SQLiteDatabase）可进行数据库的操作，如 db.query() db.delete()

如果我们想在创建一个数据库表，参照上述代码，可以在SQLiteOpenHelper的onCreate方法中加入语句:

@Override
public void onCreate(SQLiteDatebase db) {
	db.execSQL(CREATE_TABLE);
	db.execSQL(CREATE_BOOK);  //新创建一个数据库表
}
1
2
3
4
5
然后重新运行一下，发现并没有创建成功，因为KogBill.db数据库已经存在，所以MySQLiteHelper 中的onCreate方法都不会执行，解决这个办法的方法很简单，只需要将db文件删除，重新运行，便可成功，但是原来数据库中的数据都会被删除。所以需要用到MySQLiteHelper中的update方法。

class MySQLiteHelper extends SQLiteOpenHelper{
	.....
	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion){
		db.execSQL("drop table if exists book");  //如果已经存在就删除，防止重复创建
		onCreate(db);  // 再次执行onCreate 方法
	}
}
1
2
3
4
5
6
7
8
但是onUpgrade方法默认是不执行的，如何让onUpgrade方法执行，需要用到MySQLiteHelper 构造参数中的版本号：

private static final int DATABASE_VERSION = 1;//  将版本号 由 1 改为2 
1
这里将数据库版本号由1改为2，表示对数据库的升级

数据库的增删改查
添加数据

ContentValues values = new ContentValues();
	values.put("date", str1.isEmpty()?"0.0":str1);
	values.put("breakfast", ""+str2);
	values.put("lunch", ""+str3);
	values.put("dinner", ""+str4);
	values.put("happy", ""+str5);
	values.put("other", ""+str6);
	values.put("spare", ""+str7);
	long ii = db.insert("kog_bill", "", values);
	values.clear();
	if(ii != -1) {
		Utils.showToast("保存成功！", MainActivity.this);
	}else {
		Utils.showToast("保存失败！", MainActivity.this);
	}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
更新数据

ContentValues valus = new ContentValues();
valuse.put("other","12");
db.update("kogBill", values, "_id=?",new String[]{id}）；
1
2
3
删除数据

db.delete("kogBill", "_id=?",new String[]{id});
1
查询数据

db.query("kog_bill", new String[]{"_id","date","breakfast","lunch","dinner","happy","other","spare"}
		, null, null, null, null, "date desc");
1
2
使用SQL操作数据库
虽然Android 已经给我们提供了非常方便的API用于操作数据库，不过总会有些人不习惯去使用这些辅助行的方法，而是更加青睐于直接使用SQL来操作数据库，当然Android也是提供的。
添加数据

db.execSQL("insert into kogBill ("date","breakfest","lunch","dinner","happy","other","spare") values (?,?,?,?,?,?,?)", new String[]{"1921-1-1"，“123”，“1”，“1”，“11”，“2”，“3”}）；
1
更新数据

db.execSQL("update kogBill set other = ? where _id = ? ", new String[]{"12",id});
1
删除数据

db.execSQL("delete from kogBill where _id = ？”, new String[]{id});
1
使用 LitePal 操作数据库
假设编译环境为AndroidStudio。
1,引进包

dependencies{
	compile fileTree(dir:'libs', include:['*.jar'])
	compile 'com.android.support:appcompat-v7:23.2.0'
	testCompile 'junt:junt:4.12'
	compile 'org.litepal.android:core:1.3.2'   //引入litepal包
}
1
2
3
4
5
6
2,配置litepal.xml 文件
右键app/src/main 目录->New -> Directory ,创建一个assets目录，然后在 assets目录下再新建一个litepal.xml 文件，接着编辑文件中的内容

<？xml version='1.0' encoding="utf-8"?>
<litepal>
	<dbname value = "BookStore"></dbname>
	<version value="1"></version>
	<list></list>
</listepal>
1
2
3
4
5
6
其中，<dbname 标签用来指定数据库名，<version 用来指定数据库版本号，<list 标签用来指定所有映射模型。
最后还需要在配置以下 LitePalApplication, 修改AndroidManifest.xml 中的代码

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	package="com.example.litepaltest" >
	<application
		android:name="org.litepal.LitePalApplication"  //配置 LitePalApplication
		android:allowBackup="true"
		.....
	</application>
</manifest>
1
2
3
4
5
6
7
8
以上，LitePal的配置工作已经结束了，接下来使用LitePal。
首先将需要实现 javabean类 对应 数据库表.
然后将javabean类添加到映射模型列表中，修改litepal.xml 中的代码

<litepal>
	<dbname value="kogBill" ></dbname>
	<version value="1"></version>
	<list>
		<mapping class="com.example.litepaltest.book"></mapping>  //javabean类的路径
	</list>
1
2
3
4
5
6
这样所有工作就已经完成，现在只要进行任意一次数据库的操作，数据库db文件就会自动创建，比如：

Connector.getDatabase();
1
操作数据
如果需要对某个表进行数据操作，需要让其对应的javaBean类继承DataSupport

public class Book extends DataSupport { //让对应的类继承DataSupport
	...
}
1
2
3
接下来，进行添加数据的操作：

Book book = new Book();
book.setName("...");
book.setAuthor("...");
book.setPages(234);
book.setPrice(12,21);
book.setPress("unkow");
book.save();  //执行sava 就可以插入数据了
1
2
3
4
5
6
7
执行更新数据：

Book book = new Book();
book.setPrice(11.11);
book.setPress("Anchor");
book.updateAll("name = ?  and authro = ?","..","...");
1
2
3
4
删除数据：

DataSupport.deleteAll(Book.class, "price<?","13");
1
查询数据：

//查询所有
List<Book> books = DataSupport.findAll(Book.class);  
// 查询第一条
List<Book> books = DataSupport.findFirst(Book.class);
//查询最后一条
List<Book> books = DataSupport.findLast(Book.class);
//查询那几列的数据
List<Book> books = DataSupport.select("name","author).find(Book.class);
//条件查询， 页面大于400
List<Book> books = DataSupport.where("pages >?","400").find(Book.class);
//将 price 降序排序
List<Book> books = DataSupport.order(price desc").find(Book.class);
//查询前3条
List<Book> books = DataSupport.limit(3).find(Book.class);
//从下表1开始，往后查询3条
List<Book> boods = DataSupport.limit(3).offset(1),find(Book.class)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
当然这些方法也可以组合起来使用：


List<Book> books = DataSupport.select("name","author","pages")
															.where("pages>?”,"400")
															.order("pages")
															.limit(10)
															.offset(10)
															.find(Book.class);
1
2
3
4
5
6
7
如果有些特殊查询，使用上述方法无法查询时，可以使用如下语句：

Cursor c  = DataSupport.findBySQL("select * from Book where pages > ? and price < ？”, 
		"400","20”);


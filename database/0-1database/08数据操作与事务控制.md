# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")
![alt text](../../static/common/svg/luoxiaosheng_gitee.svg "码云")


## 数据操作与事务控制

### 要点

• INSERT语句

• UPDATE语句

• DELETE语句

• 9i新增MERGE语句

• COMMIT命令

• ROLLBACK命令

• 管理锁

### 数据操作与事务控制

• 数据操作语言（DML： Data Manipulation Language）

• 主要包括以下语句：

– INSERT

– UPDATE

– DELETE

– MERGE

• 事务是一组相关的DML语句的逻辑组合。事务控制主要包括下 列命令：

– COMMIT

– ROLLBACK

– SAVEPOINT

### 插入数据INSERT语法结构
• 语法如下：

INSERT INTO 表名[(列名1[,列名2，…，列名n])] VALUES (值1[,值2，…，值n]);

– 一次只插入一行

– NULL的使用，连续的单引号（‘’）也可以表示空值。

– 插入日期型数据

– 插入特殊字符

– 插入多行数据

– 按列的默认顺序列出各个列的值

– 在Insert子句中可以随意列出列名和他们的值

– 字符和日期型数据应该包含在单引号中

#### INSERT语句插入空值（NULL）

• 例8-1 将一个新成立部门的信息写入departments表
INSERT INTO departments VALUES(300,'Operations',110,1500);

• 显示默认值概述 – 使用Default表示默认值

– 符合SQL：1999标准

– 可以使用显示默认值控制默认值的使用

– 显示默认值可以在insert和update语句中使用

• 例8-2 将一个新成立部门的信息写入departments中 ，其中管 理者未知。

INSERT INTO departments VALUES(310,'Operations', NULL,1500);

或

INSERT INTO departments VALUES(310,'Operations', '',1500);

或

INSERT INTO departments (department_id,department_name,location_id) VALUES(310,'Operations',1500);

#### INSERT语句插入日期型数据

• 例8-5 将一新入职员工信息写入employees表

INSERT INTO employees(employee_id,last_name,email,hire_date,job_id) VALUES(210,’Wang’,’SWANG’,’ 10-9月-

06’,’IT_PROG’);

或

INSERT INTO employees(employee_id,last_name,email,hire_date,job_id) VALUES(210,’Wang’,’SWANG’,TO_DATE(’2006-9-

10’,’YYYY-MM-DD’),’IT_PROG’);

#### INSERT语句插入特殊字符

•   INSERT INTO test VALUES（‘&TEST&’）; 查看ESCAPE转义符用哪个符号表示。

SHOW ESCAPE； ——查看ESCAPE状态 escape OFF 
——返回ESCAPE状态为OFF SET ESCAPE ON； 
——设定ESCAPE状态为ON SHOW ESCAPE； 
——查看ESCAPE状态 escape "\" (hex 5c) 
——返回ESCAPE符号为“\” INSERT语句中使用“\”符对特殊符号转义。

• INSERT INTO test VALUES（‘\&TEST\&’）;

#### INSERT语句插入多行数据

• 语法

INSERT INTO表名[(列名1[,列名2，…，列名n])] 子查询 ；

• 例8-7 将受雇日期在“1995-1-1”之前的员工信息复制到 hemployees表中。

INSERT INTO hemployees SELECT * FROM employees WHERE hire_date<TO_DATE(‘1995-1-1’,’YYYY-MM-DD’);

不必书写values子句 INSERT子句中列的数量和类型必须和子查询中列的数量 和类型相匹配


### 修改数据UPDATE语法结构
• UPDATE语法结构

UPDATE 表名 SET 列名=表达式[，列名=表达式， [WHERE 条件表达式]；

]

• UPDATE简单修改

UPDATE employees SET salary=salary*(1+0.2);

UPDATE employees SET salary=salary+200,manager_id=103 WHERE department_id=60;

• 嵌入子查询修改

UPDATE employees SET department_id=10, salary=500+(SELECT AVG(salary) FROM employees) WHERE job_id=(SELECT job_id FROM employees WHERE employee_id=110) AND employee_id<>110;

• 除基于表自身实现嵌入子查询的方式实现修改操作外，也可以 在子查询中基于其他表实现修改操作。

• 相关子查询修改 – update employees a set salary = salary+(select avg(salary) from employees b where b.department_id = a.department_id)

#### 修改数据(完整性错误)

• update employees set department_id = 55 where department_id = 100;

• ORA-02291: 违反完整约束条件 (NEU.EMP_DEPT_FK) - 未找 到父项关键字

### 删除数据DELETE语法结构
• DELETE语法结构

DELETE [FROM] 表名 [WHERE 条件表达式]；

• DELETE删除数据

DELETE FROM departments WHERE department_id=210;

• 例8-12 删除管理者编号（manager_id）为205的部门，相应部 门的员工予以解聘，不包括205号员工。

DELETE FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE manager_id =205) AND employee_id<>205;

• DELETE语句不能删除被其他表引用了的记录值。

• 删除数据 （完整性错误） – delete from departments where department_id = 100;

– ORA-02292: 违反完整约束条件 (NEU.EMP_DEPT_FK) - 已 找到子记录日志

• 删除数据 （相关子查询） – delete emp_copy a

– where exists (select '1' from employees b where b.employee_id = a.employee_id)

### 合并数据MERGE语法结构
• 根据指定的条件执行插入或者更新操作

• 如果满足条件的行存在，执行更新操作，否则执行插入操作

• 优点： 避免独立的数据更新 提高效率而且使用方便 在数据仓库应用中经常使用
• MERGE语法结构

MERGE INTO table_name [t_alias] 
USING { table | view | subquery } [t_alias] 
ON ( join condition ) 
WHEN MATCHED THEN 
UPDATE SET col1=col1_val[,col2=col2_val ] 
WHEN NOT MATCHED THEN 
INSERT（column_list） VALUES（column_values）;

– INTO 子句：指定更新或插入的目标表

– USING 子句：指定更新或插入的数据源，它可以是表、视图、 子查询

– ON 子句：合并操作的条件判断语句

MERGE INTO emp a USING employees b ON(a.employee_id=b.employee_id) WHEN MATCHED THEN UPDATE SET a.email=b.email,a.phone_number=b.phone_number, a.salary=b.salary, a.manager_id=b.manager_id, a.department_id=b.department_id WHEN NOT MATCHED THEN INSERT (employee_id,email,phone_number,salary,manager_id,departm ent_id) VALUES(b.employee_id, b.email, b.phone_number, b.salary, b.manager_id, b.department_id);

该例子显示匹配employees表中的employee_id列与emp表中的employee_id列。 如果找到了一个匹配，用employees表中匹配行的列值更新emp表中匹配的 列值。如果相匹配行没有找到， employees表中的列值被插入到emp表中。


###
#### 事务概率
• 概念：事务（Transaction）也称工作单元，是一个或多个SQL 语句所组成的序列，这些SQL操作作为一个完整的工作单元， 要么全部执行，要么全部不执行。通过事务的使用，能够使一 系列相关操作关联起来，防止出现数据不一致现象。

• 事务的组成：在ORACLE数据库中，事务由以下语句组成：

– 一组相关的DML语句，修改的数据在该组语句中保持一致

– 一个 DDL语句或者一个 DCL语句或者一个TCL语句

#### 事务特征

• 可用四个字母的缩写表示：即ACID

• 原子性（Atomicity）

– 事务就像一个独立的工作单元。原子性保证要么所有的操 作都成功，要不全都失败。如果所有的动作都成功了，我 们就说这个事务成功了，不然就是失败的，然后回滚。

• 一致性（Consistency）

– 一旦事务完成了（不管是成功的，还是失败的），整个系 统处于操作规则的统一状态，也就是说，数据不会损坏。

• 隔离性（Isolation）

– 事务的隔离性是指数据库中一个事务的执行不能被其它事 务干扰。所以，事务应该隔离起来，目的为了防止同时的 读和写操作。这就需要事务与锁同时使用。

• 持久性（Durability）

– 事务的持久性也称为永久性（Permanence），指事务一旦 提交，则其对数据库中数据的改变就是永久的。

#### 事务控制
• 事务的控制分为：显式控制及隐式控制。

• 显示控制：

– 显示提交：Commit

– 显示回滚：Rollback

• 隐式控制： – 隐式提交：当下列任意一种情况发生时，会发生隐式提交

a. 执行一个DDL 语句

b. 执行一个DCL 语句

c. 从 SQL*Plus正常退出（即使用EXIT或QUIT命令退出）

– 隐式回滚：当下列任意一种情况发生时，会发生隐式回滚

a. 从SQL*Plus中强行退出

b. 客户端连接到服务器端异常中断

c. 系统崩溃

#### 事务的主要命令
• 事务控制的命令主要有以下三个：

– 事务提交：COMMIT

– 事务回滚：ROLLBACK

– 设立保存点：SAVEPOINT（作为辅助命令使用）

• 设置保存点语法：

– SAVEPOINT 保存点名称； ——定义保存点

– ROLLBACK TO保存点名称; ——回滚到已定义保存点

#### 事务的开始和结束
• 开始：事务开始于上一个事务结束后执行的第一个DML语句
• 结束：事务结束于下面的任一种情况的发生：

– 执行了COMMIT 或者ROLLBACK命令

– 隐式提交（单个的DDL或DCL语句）或自动提交

– 用户退出

– 系统崩溃

#### 事务自动提交

• 设置格式：

SET AUTOCOMMIT [ON|OFF];

• 例8-14 SQL*Plus自动提交的应用示例

SHOW AUTOCOMMIT; ——查看AUTOCOMMIT变量状态 autocommit OFF SET AUTOCOMMIT ON； ——把变量状态设置为ON INSERT INTO test VALUES (‘TEST’); 已创建 1 行 提交完成 ——已经自动提交 41

#### 事务控制示例

DELETE FROM test ; 
ROLLBACK; ——撤消DELETE操作 
INSERT INTO test VALUES(’A’); 
SAVEPOINT insert_a; ——定义insert_a保存点 
INSERT INTO test VALUES(’B’); 
SAVEPOINT insert_b; ——定义insert_b保存点 
INSERT INTO test VALUES(’C’); 
ROLLBACK TO insert_b; ——撤消操作到insert_b保存点 
DELETE FROM test WHERE test_str = ‘A’; 
COMMIT; ——将所有修改写入数据库 
ROLLBACK; ——所有操作已经COMMIT提交，不能 回滚

#### 事务执行Commit或Rollback前的数据状态

– 数据变化前的状态可以被恢复

– 当前会话可以使用SELECT语句来验证 DML操作后的结果

– 其它会话不能查看由当前用户的DML操作结果

– 受影响记录被锁定，也就是其它用户不能改变受影响记录 中的数据

• Commit后的状态
– 在数据库中数据变化成为永久性的
– 先前的数据状态永久性的消失
– 所有用户/会话都可以查询提交后的结果
– 锁定的记录被释放，可以有效地被其他用户操作
– 所有的存储节点被清除

• Rollback后的数据状态
– 使用ROLLBACK 可以放弃所有悬而未决的变化。 
¯数据变化是可以撤销的 
¯先前的数据状态被恢复 
¯锁定的记录被释放 
¯所有的存储节点被清除

### 事务的读一致性
• 读一致性保证了不同会话在同一时间查看数据时，数据一致。

• ORACLE在两个不同级别上提供读一致性：语句级读一致性和 事务级一致性。

• 事务级一致性，当一个会话正在修改数据时，其它的会话将看 不到该会话未提交的修改。

• 语句级读一致性，保证单个查询所返回的数据与该查询开始时 刻相一致。所以一个查询从不会看到在查询执行过程中提交的 其它事务所作的任何修改。

### 锁

#### 锁-并发事务
• 并发事务

– 并发事务：如果多个事务同时访问某一个资源，比如同时 修改表中的某一行。

#### 并发事务常见问题
– 并发事务可能出现如下问题:

• 1.脏读取:就是读取了未提交的数据，如B事务读取了A 事务未提交的数据

• 2.不可重复读取:就是一个事务在读取一个数据时，数据 不同，可能是另一个事务修改了数据。

• 3.更新丢失:就是两个事务同时更新了一条数据，先更新 的就会丢失数据。

• 4.幻想读:事务A在读取数据的时候，数据发生了变化。

#### 锁的概念
• 锁用来在多用户并发访问和操作数据库时保证数据的一致性。 锁由Oracle自动管理。如一个DML操作，ORACLE默认的机制 是在DML操作涉及到的行上加锁（行级别），但不会在更高的 级别（表级别）上加更严格的锁，比如只改某行的数据不会锁 住整个表。这提供了很好的并发性，因为整个表没有锁定，只 是某些行被锁定了，其他用户可以修改其他行数据。

• 查询不需要任何锁。

• 锁的生命周期，锁在被相关的操作申请并持有后，会一直保持 到事务的结束。事务结束后，锁才会被释放。

• 锁的内部维护机制是采用排队机制（enqueue），一个对象的 排它锁被持有后，该对象相同级别的锁被其他事务申请时候， 所有等待该锁的事务都在一个等待队列中排队，其他事务处于 等待状态。直到该锁被释放，等待的事务才重新竞争使用该资 源。

• 锁的模式
    – 排它锁模式（Exclusive）排它锁在被释放之前，会阻止其 锁住的资源被其他任何事务共享。
    – 共享模式（Share）

#### 锁的分类
• 两种类型的锁，DML锁和DDL锁。

• DML锁，也称数据锁，用于在数据被多个不同的用户改变时， 保证数据的完整性。

• DDL锁，也称为数据字典锁，执行DDL语句时，DDL语句涉及 到的对象获得DDL锁。由于被持有的时间很短，因此很少看到 冲突的DDL锁，并且以nowait方式被请求。

#### 3种DDL锁类型：

– 排它的DDL锁，很多对象的创建、修改和删除定义时候都 需要获得该锁。比如执行Create Table、Drop Table等时会 获得表上的排它DDL锁。

– 共享的DDL锁。在执行Grant、Create Procedure等命令时， 会获得命令相关操作对象的共享DDL锁。

– Breakable Parse Lock，用来在共享SQL区校验语句。

#### 锁的使用

• ORACLE中实现加锁机制主要有两种方式：

– 1.自动加锁

– 2.手动加锁


• 自动加锁
– 用户在执行INSERT，UPDATE，DELETE，DCL， DDL语句时，ORACLE会自动加锁。
– 在一个事务中，ORACLE会自动锁定执行以上语句的 数据库对象，只有事务结束（提交或者回滚），资源 才能被释放。
– 默认情况下，更新数据时ORACLE会自动提供排他锁， 使不同用户在更新表中同一数据时不会发生冲突。 l 例 模拟两个会话，同时修改员工编号198的员工信息

• 手动加锁
– 除了自动加锁之外，也可以使用手动加锁。
– 语法常见的有两种：
• 1.表加锁语法 LOCK TABLE 表名 IN 锁类型 MODE [NOWAIT] 锁类型: Exclusive,Share

2.行加锁语法 SELECT…FROM…FOR UPDATE [NOWAIT] NOWAIT选项是当申请加锁不成功时，就不再等待

### 使用锁的常见问题

• 如使用锁的方式不当，可能会产生锁冲突，不适当的使用方式 包括：

– 不必要的高级别的锁

– 长时间运行的事务

– 没有提交的事务

– 其他产品产生了高级别的锁

• 死锁：当两个或者两个以上的用户彼此等待被对方锁定的资源 时，就有可能产生死锁。

### 锁的例子(死锁)

• 会话A在时间T1修改资源X，未进行提交

• 会话B在时间T2修改资源Y，未进行提交

• 会话A在时间T3修改资源Y，未进行提交

• 会话B在时间T4修改资源X，死锁产生



